// Generated by CoffeeScript 1.4.0
(function() {
  var AWS, Civi, Config, Crypto, HTTP, Lambda, PROCESS_MESSAGE, Poll, Promise, Slack, bluebird, civi, civi_poll, querystring, request, slack, slack_poll, sqs;

  querystring = require('querystring');

  AWS = require('aws-sdk');

  bluebird = require('bluebird');

  Promise = bluebird.Promise;

  AWS.config.setPromisesDependency();

  HTTP = require('http');

  request = require('request');

  Crypto = require('crypto-js');

  sqs = new AWS.SQS({
    refion: 'us-west-1'
  });

  Lambda = new AWS.Lambda();

  PROCESS_MESSAGE = 'process-message';

  Config = {
    civi_queue: process.env['CIVI_QUEUE'],
    slack_queue: process.env['SLACK_QUEUE'],
    slack_bot: process.env['SLACK_BOT'],
    civi_site_key: process.env['CIVI_SITE_KEY'],
    civi_user_key: process.env['CIVI_USER_KEY'],
    civi_endpoint: process.env['CIVI_API']
  };

  Poll = (function() {

    function Poll(queue_url, emitter) {
      this.queue = queue_url;
      this.emitter = emitter;
    }

    Poll.prototype.fetch = function() {
      var params,
        _this = this;
      console.log("Poll queue " + this.queue);
      params = {
        QueueUrl: this.queue,
        MaxNumberOfMessages: 10,
        VisibilityTimeout: 15
      };
      return new Promise(function(ok, fail) {
        return sqs.receiveMessage(params, function(err, data) {
          console.log("Omg! received messages " + err + ": " + (JSON.stringify(data)));
          if (err) {
            return fail(err);
          } else {
            return ok(data.Messages);
          }
        });
      });
    };

    Poll.prototype["delete"] = function(message) {
      var params,
        _this = this;
      params = {
        QueueUrl: this.queue,
        ReceiptHandle: message.ReceiptHandle
      };
      console.log("DELETE message " + message.ReceiptHandle);
      return new Promise(function(ok, fail) {
        return sqs.deleteMessage(params, function(err) {
          if (err) {
            return fail(err);
          } else {
            return ok(null);
          }
        });
      });
    };

    Poll.prototype.process = function(ok, fail) {
      var _this = this;
      return this.fetch().then(function(msg_list) {
        if (msg_list != null) {
          console.log("Processing " + msg_list.length + " events");
          return Promise.all(msg_list.map(function(msg) {
            var body;
            console.log("emit: " + msg.Body);
            body = JSON.parse(msg.Body);
            return _this.emitter.emit(body).then(_this["delete"](msg));
          }));
        } else {
          console.log("no messages to process");
          return [];
        }
      })["catch"](function(error) {
        return fail(error);
      });
    };

    return Poll;

  })();

  Slack = (function() {

    function Slack(webhook, channel) {
      this.webhook = webhook;
      this.channel = channel;
    }

    Slack.prototype.say = function(what) {
      var data,
        _this = this;
      data = {
        channel: this.channel,
        text: what,
        as_user: false,
        username: "akcjabot"
      };
      return new Promise(function(ok, fail) {
        var opts;
        opts = {
          json: data
        };
        return request.post(_this.webhook, opts, function(err, status, body) {
          if (err) {
            return fail(err);
          } else {
            return ok(body);
          }
        });
      });
    };

    Slack.prototype.petition_flagged = function(petition) {
      return this.say("Kampania _" + petition.title + "_ zosta≈Ça oznaczona do moderacji " + petition.url + ".");
    };

    Slack.prototype.petition_launched = function(petition) {
      return this.say("Nowa kampania _" + petition.title + "_ " + petition.url + ".");
    };

    Slack.prototype.petition_updated = function(petition) {
      return this.say("Zmiana w kampanii _" + petition.title + "_ " + petition.url + ".");
    };

    Slack.prototype.blast_created = function(blast) {
      return this.say("Nowy blast: _" + blast.subject + "_ od " + blast.from_name + " <" + blast.from_address + ">");
    };

    Slack.prototype.event_created = function(event) {
      return this.say("Nowe wydarzenie: _" + event.title + "_ " + event.url);
    };

    Slack.prototype.event_updated = function(event) {
      return this.say("Zmiana wydarzenia: _" + event.title + "_ " + event.url);
    };

    Slack.prototype.emit = function(message) {
      switch (message.type) {
        case "petition.launched":
          return this.petition_launched(message.data);
        case "petition.launched.ham":
          return this.petition_launched(message.data);
        case "petition.launched.requires_moderation":
          return this.petition_launched(message.data);
        case "petition.flagged":
          return this.petition_flagged(message.data);
        case "blast_email.created":
          return this.blast_created(message.data);
        case "event.created":
          return this.event_created(message.data);
        case "event.updated":
          return this.event_updated(message.data);
        case "petition.updated":
          return this.petition_updated(message.data);
        case "petition.updated.requires_moderation":
          return this.petition_updated(message.data);
        default:
          throw "slack emitter does not support type " + message.type;
      }
    };

    return Slack;

  })();

  Civi = (function() {

    function Civi(endpoint, site_key, user_key) {
      this.endpoint = endpoint;
      this.key = site_key;
      this.api_key = user_key;
    }

    Civi.prototype.api = function(entity, action, params) {
      var _this = this;
      return new Promise(function(ok, fail) {
        var opts;
        params.sequential = 1;
        opts = {
          qs: {
            key: _this.key,
            api_key: _this.api_key,
            entity: entity,
            action: action,
            json: JSON.stringify(params)
          }
        };
        return request.get(_this.endpoint, opts, function(err, status, body) {
          var data;
          if (err) {
            return fail(err);
          } else {
            console.log("CIVI API: " + body);
            data = JSON.parse(body);
            if (data.is_error > 0) {
              return fail("Civi API call error body:" + body);
            } else {
              return ok(data);
            }
          }
        });
      });
    };

    Civi.prototype.petition_external_id = function(petition) {
      return "nd:csl:" + Crypto.enc.Base64.stringify(Crypto.MD5("petition:" + petition.slug));
    };

    Civi.prototype.civi_campaign_slug = function(petition) {
      return "ND_" + petition.slug;
    };

    Civi.prototype.civi_campaign_title = function(petition) {
      return "ND " + petition.title;
    };

    Civi.prototype.civi_campaign_hash = function(petition) {
      return {
        external_identifier: this.petition_external_id(petition),
        name: this.civi_campaign_slug(petition),
        title: this.civi_campaign_title(petition)
      };
    };

    Civi.prototype.create_or_update_petition = function(petition) {
      var external_id,
        _this = this;
      external_id = this.petition_external_id(petition);
      return this.api('Campaign', 'get', {
        external_identifier: external_id
      }).then(function(civi_campaigns) {
        var cc, cc_data;
        if (civi_campaigns.values.length === 0) {
          console.log("no campaign with this external id");
          cc_data = _this.civi_campaign_hash(petition);
          return _this.api('Campaign', 'create', cc_data);
        } else {
          cc = civi_campaigns[0];
          console.log("there is a campaign: " + cc.title + " (" + cc.id + ")");
          if (cc.title !== _this.civi_campaign_slug(petition)) {
            cc_data = _this.civi_campaign_hash(petition);
            cc_data.id = cc.id;
            return _this.api('Campaign', 'create', cc_data);
          } else {
            return cc;
          }
        }
      });
    };

    Civi.prototype.emit = function(message) {
      console.log("Civi: message type: " + message.type);
      switch (message.type) {
        case "petition.launched":
          return this.create_or_update_petition(message.data);
        default:
          throw "slack emitter does not support type " + message.type;
      }
    };

    return Civi;

  })();

  slack = new Slack(Config.slack_bot, '#naszademokracja');

  slack_poll = new Poll(Config.slack_queue, slack);

  civi = new Civi(Config.civi_endpoint, Config.civi_site_key, Config.civi_user_key);

  civi_poll = new Poll(Config.civi_queue, civi);

  exports.event = function(event, context, callback) {
    var fail, ok;
    ok = function(x) {
      return callback(null);
    };
    fail = function(err) {
      return callback(err);
    };
    return civi_poll.process(ok, fail);
  };

}).call(this);
